{"version":3,"file":"constrainedEditorPlugin.js","mappings":";;;;;;;;;;;;;;;;;AAA6C;AACR;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA,sEAAsE;AACtE,YAAY;AACZ,yHAAyH;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6IAA6I;AAC7I;AACA,YAAY;AACZ,2IAA2I;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yHAAyH;AACzH;AACA;AACA,uIAAuI;AACvI;AACA,YAAY;AACZ,uHAAuH;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yIAAyI;AACzI;AACA,YAAY;AACZ,yIAAyI;AACzI;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,+DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU,GAAG,UAAU,KAAK,QAAQ,EAAE,OAAO;AAC7E;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAS;AAC5B;AACA;AACA;AACA;AACA,uEAAuE,mFAAiC;AACxG,qEAAqE,kFAAgC;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,+BAA+B,gBAAgB,kCAAkC;AACjF,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iEAAe,gBAAgB;;;;;;;;;;;;;;;ACjjBxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,eAAe;AACtB;AACA,0DAA0D;AAC1D,mBAAmB,UAAU;AAC7B,gBAAgB;AAChB,KAAK;AACL,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED,iEAAe,SAAS;;;;;;;;;;;;;;;ACxEjB;AACP;AACA;AACA;AACA;AACA;AACA,iEAAe,aAAa;;;;;;;;;;;;;;;ACNrB;AACP;AACA;AACA;AACA,iEAAe,KAAK;;;;;;;;;;;;;;ACJpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,UAAU;;;;;;UC3CzB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;;ACN+C;AACO;AACD;;AAE9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB,EAAE;AACxD;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU,+CAA+C,EAAE,qEAAmB;AAC9E;AACA;AACA,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA,QAAQ,mEAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA,iCAAiC,gEAAgB;AACjD;AACA;AACA,QAAQ;AACR;AACA,UAAU,mEAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,QAAQ,mEAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA,QAAQ,mEAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wDAAwD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,iEAAe,iBAAiB,EAAC","sources":["webpack://constrainedEditor/./src/constrainedModel.js","webpack://constrainedEditor/./src/utils/deepClone.js","webpack://constrainedEditor/./src/utils/definedErrors.js","webpack://constrainedEditor/./src/utils/enums.js","webpack://constrainedEditor/./src/utils/validators.js","webpack://constrainedEditor/webpack/bootstrap","webpack://constrainedEditor/webpack/runtime/define property getters","webpack://constrainedEditor/webpack/runtime/hasOwnProperty shorthand","webpack://constrainedEditor/webpack/runtime/make namespace object","webpack://constrainedEditor/./src/constrainedEditor.js"],"sourcesContent":["import deepClone from './utils/deepClone.js';\nimport enums from './utils/enums.js';\nexport const constrainedModel = function (model, ranges, monaco) {\n  const rangeConstructor = monaco.Range;\n  const sortRangesInAscendingOrder = function (rangeObject1, rangeObject2) {\n    const rangeA = rangeObject1.range;\n    const rangeB = rangeObject2.range;\n    if (\n      rangeA[0] < rangeB[0] ||\n      (rangeA[0] === rangeB[0] && rangeA[3] < rangeB[1])\n    ) {\n      return -1;\n    }\n  }\n  const normalizeRange = function (range, content) {\n    const lines = content.split('\\n');\n    const noOfLines = lines.length;\n    const normalizedRange = [];\n    range.forEach(function (value, index) {\n      if (value === 0) {\n        throw new Error('Range values cannot be zero');//No I18n\n      }\n      switch (index) {\n        case 0: {\n          if (value < 0) {\n            throw new Error('Start Line of Range cannot be negative');//No I18n\n          } else if (value > noOfLines) {\n            throw new Error('Provided Start Line(' + value + ') is out of bounds. Max Lines in content is ' + noOfLines);//No I18n\n          }\n          normalizedRange[index] = value;\n        }\n          break;\n        case 1: {\n          let actualStartCol = value;\n          const startLineNo = normalizedRange[0];\n          const maxCols = lines[startLineNo - 1].length\n          if (actualStartCol < 0) {\n            actualStartCol = maxCols - Math.abs(actualStartCol);\n            if (actualStartCol < 0) {\n              throw new Error('Provided Start Column(' + value + ') is out of bounds. Max Column in line ' + startLineNo + ' is ' + maxCols);//No I18n\n            }\n          } else if (actualStartCol > (maxCols + 1)) {\n            throw new Error('Provided Start Column(' + value + ') is out of bounds. Max Column in line ' + startLineNo + ' is ' + maxCols);//No I18n\n          }\n          normalizedRange[index] = actualStartCol;\n        }\n          break;\n        case 2: {\n          let actualEndLine = value;\n          if (actualEndLine < 0) {\n            actualEndLine = noOfLines - Math.abs(value);\n            if (actualEndLine < 0) {\n              throw new Error('Provided End Line(' + value + ') is out of bounds. Max Lines in content is ' + noOfLines);//No I18n\n            }\n            if (actualEndLine < normalizedRange[0]) {\n              console.warn('Provided End Line(' + value + ') is less than the start Line, the Restriction may not behave as expected');//No I18n\n            }\n          } else if (value > noOfLines) {\n            throw new Error('Provided End Line(' + value + ') is out of bounds. Max Lines in content is ' + noOfLines);//No I18n\n          }\n          normalizedRange[index] = actualEndLine;\n        }\n          break;\n        case 3: {\n          let actualEndCol = value;\n          const endLineNo = normalizedRange[2];\n          const maxCols = lines[endLineNo - 1].length\n          if (actualEndCol < 0) {\n            actualEndCol = maxCols - Math.abs(actualEndCol);\n            if (actualEndCol < 0) {\n              throw new Error('Provided End Column(' + value + ') is out of bounds. Max Column in line ' + endLineNo + ' is ' + maxCols);//No I18n\n            }\n          } else if (actualEndCol > (maxCols + 1)) {\n            throw new Error('Provided Start Column(' + value + ') is out of bounds. Max Column in line ' + endLineNo + ' is ' + maxCols);//No I18n\n          }\n          normalizedRange[index] = actualEndCol;\n        }\n          break;\n      }\n    })\n    return normalizedRange;\n  }\n  let restrictions = deepClone(ranges).sort(sortRangesInAscendingOrder);\n  const prepareRestrictions = function (restrictions) {\n    const content = model.getValue();\n    restrictions.forEach(function (restriction, index) {\n      const range = normalizeRange(restriction.range, content);\n      const startLine = range[0];\n      const startCol = range[1];\n      const endLine = range[2];\n      const endCol = range[3];\n      restriction._originalRange = range.slice();\n      restriction.range = new rangeConstructor(startLine, startCol, endLine, endCol);\n      restriction.index = index;\n      if (!restriction.allowMultiline) {\n        restriction.allowMultiline = rangeConstructor.spansMultipleLines(restriction.range)\n      }\n      if (!restriction.label) {\n        restriction.label = `[${startLine},${startCol} -> ${endLine}${endCol}]`;\n      }\n    });\n  }\n  const getCurrentEditableRanges = function () {\n    return restrictions.reduce(function (acc, restriction) {\n      acc[restriction.label] = {\n        allowMultiline: restriction.allowMultiline || false,\n        index: restriction.index,\n        range: Object.assign({}, restriction.range),\n        originalRange: restriction._originalRange.slice()\n      };\n      return acc;\n    }, {});\n  }\n  const getValueInEditableRanges = function () {\n    return restrictions.reduce(function (acc, restriction) {\n      acc[restriction.label] = model.getValueInRange(restriction.range);\n      return acc;\n    }, {});\n  }\n  const updateValueInEditableRanges = function (object, forceMoveMarkers) {\n    if (typeof object === 'object' && !Array.isArray(object)) {\n      forceMoveMarkers = typeof forceMoveMarkers === 'boolean' ? forceMoveMarkers : false;\n      const restrictionsMap = restrictions.reduce(function (acc, restriction) {\n        if (restriction.label) {\n          acc[restriction.label] = restriction;\n        }\n        return acc;\n      }, {});\n      for (let label in object) {\n        const restriction = restrictionsMap[label];\n        if (restriction) {\n          const value = object[label];\n          if (doesChangeHasMultilineConflict(restriction, value)) {\n            throw new Error('Multiline change is not allowed for ' + label);\n          }\n          const newRange = deepClone(restriction.range);\n          newRange.endLine = newRange.startLine + value.split('\\n').length - 1;\n          newRange.endColumn = value.split('\\n').pop().length;\n          if (isChangeInvalidAsPerUser(restriction, value, newRange)) {\n            throw new Error('Change is invalidated by validate function of ' + label);\n          }\n          model.applyEdits([{\n            forceMoveMarkers: !!forceMoveMarkers,\n            range: restriction.range,\n            text: value\n          }]);\n        } else {\n          console.error('No restriction found for ' + label);\n        }\n      }\n    } else {\n      throw new Error('Value must be an object');//No I18n\n    }\n  }\n  const disposeRestrictions = function () {\n    model._restrictionChangeListener.dispose();\n    window.removeEventListener(\"error\", handleUnhandledPromiseRejection);\n    delete model.editInRestrictedArea;\n    delete model.disposeRestrictions;\n    delete model.getValueInEditableRanges;\n    delete model.updateValueInEditableRanges;\n    delete model.updateRestrictions;\n    delete model.getCurrentEditableRanges;\n    delete model.toggleHighlightOfEditableAreas;\n    delete model._hasHighlight;\n    delete model._isRestrictedModel;\n    delete model._isCursorAtCheckPoint;\n    delete model._currentCursorPositions;\n    delete model._editableRangeChangeListener;\n    delete model._restrictionChangeListener;\n    delete model._oldDecorations;\n    delete model._oldDecorationsSource;\n    return model;\n  }\n  const isCursorAtCheckPoint = function (positions) {\n    positions.some(function (position) {\n      const posLineNumber = position.lineNumber;\n      const posCol = position.column;\n      const length = restrictions.length;\n      for (let i = 0; i < length; i++) {\n        const range = restrictions[i].range;\n        if (\n          (range.startLineNumber === posLineNumber && range.startColumn === posCol) ||\n          (range.endLineNumber === posLineNumber && range.endColumn === posCol)\n        ) {\n          model.pushStackElement();\n          return true;\n        }\n      }\n    });\n  };\n  const addEditableRangeListener = function (callback) {\n    if (typeof callback === 'function') {\n      model._editableRangeChangeListener.push(callback);\n    }\n  };\n  const triggerChangeListenersWith = function (currentChanges, allChanges) {\n    const currentRanges = getCurrentEditableRanges();\n    model._editableRangeChangeListener.forEach(function (callback) {\n      callback.call(model, currentChanges, allChanges, currentRanges);\n    });\n  };\n  const doUndo = function () {\n    return Promise.resolve().then(function () {\n      model.editInRestrictedArea = true;\n      model.undo();\n      model.editInRestrictedArea = false;\n      if (model._hasHighlight && model._oldDecorationsSource) {\n        // id present in the decorations info will be omitted by monaco\n        // So we don't need to remove the old decorations id\n        model.deltaDecorations(model._oldDecorations, model._oldDecorationsSource);\n        model._oldDecorationsSource.forEach(function (object) {\n          object.range = model.getDecorationRange(object.id);\n        });\n      }\n    });\n  };\n  const updateRange = function (restriction, range, finalLine, finalColumn, changes, changeIndex) {\n    let oldRangeEndLineNumber = range.endLineNumber;\n    let oldRangeEndColumn = range.endColumn;\n    restriction.prevRange = range;\n    restriction.range = range.setEndPosition(finalLine, finalColumn);\n    const length = restrictions.length;\n    let changesLength = changes.length;\n    const diffInCol = finalColumn - oldRangeEndColumn;\n    const diffInRow = finalLine - oldRangeEndLineNumber;\n\n    const cursorPositions = model._currentCursorPositions || [];\n    const noOfCursorPositions = cursorPositions.length;\n    // if (noOfCursorPositions > 0) {\n    if (changesLength !== noOfCursorPositions) {\n      changes = changes.filter(function (change) {\n        const range = change.range;\n        for (let i = 0; i < noOfCursorPositions; i++) {\n          const cursorPosition = cursorPositions[i];\n          if (\n            (range.startLineNumber === cursorPosition.startLineNumber) &&\n            (range.endLineNumber === cursorPosition.endLineNumber) &&\n            (range.startColumn === cursorPosition.startColumn) &&\n            (range.endColumn === cursorPosition.endColumn)\n          ) {\n            return true;\n          }\n        }\n        return false;\n      });\n      changesLength = changes.length;\n    }\n    if (diffInRow !== 0) {\n      for (let i = restriction.index + 1; i < length; i++) {\n        const nextRestriction = restrictions[i];\n        const nextRange = nextRestriction.range;\n        if (oldRangeEndLineNumber === nextRange.startLineNumber) {\n          nextRange.startColumn += diffInCol;\n        }\n        if (oldRangeEndLineNumber === nextRange.endLineNumber) {\n          nextRange.endColumn += diffInCol;\n        }\n        nextRange.startLineNumber += diffInRow;\n        nextRange.endLineNumber += diffInRow;\n        nextRestriction.range = nextRange;\n      }\n      for (let i = changeIndex + 1; i < changesLength; i++) {\n        const nextChange = changes[i];\n        const rangeInChange = nextChange.range;\n        const rangeAsString = rangeInChange.toString();\n        const rangeMapValue = rangeMap[rangeAsString];\n        delete rangeMap[rangeAsString];\n        if (oldRangeEndLineNumber === rangeInChange.startLineNumber) {\n          rangeInChange.startColumn += diffInCol;\n        }\n        if (oldRangeEndLineNumber === rangeInChange.endLineNumber) {\n          rangeInChange.endColumn += diffInCol;\n        }\n        rangeInChange.startLineNumber += diffInRow;\n        rangeInChange.endLineNumber += diffInRow;\n        nextChange.range = rangeInChange;\n        rangeMap[rangeInChange.toString()] = rangeMapValue;\n      }\n    } else {\n      // Only Column might have changed\n      for (let i = restriction.index + 1; i < length; i++) {\n        const nextRestriction = restrictions[i];\n        const nextRange = nextRestriction.range;\n        if (nextRange.startLineNumber > oldRangeEndLineNumber) {\n          break;\n        } else {\n          nextRange.startColumn += diffInCol;\n          nextRange.endColumn += diffInCol;\n          nextRestriction.range = nextRange;\n        }\n      }\n      for (let i = changeIndex + 1; i < changesLength; i++) {\n        // rangeMap\n        const nextChange = changes[i];\n        const rangeInChange = nextChange.range;\n        const rangeAsString = rangeInChange.toString();\n        const rangeMapValue = rangeMap[rangeAsString];\n        delete rangeMap[rangeAsString];\n        if (rangeInChange.startLineNumber > oldRangeEndLineNumber) {\n          rangeMap[rangeInChange.toString()] = rangeMapValue;\n          break;\n        } else {\n          rangeInChange.startColumn += diffInCol;\n          rangeInChange.endColumn += diffInCol;\n          nextChange.range = rangeInChange;\n          rangeMap[rangeInChange.toString()] = rangeMapValue;\n        }\n      }\n    }\n    // }\n  };\n  const getInfoFrom = function (change, editableRange) {\n    const info = {};\n    const range = change.range;\n    // Get State\n    if (change.text === '') {\n      info.isDeletion = true;\n    } else if (\n      (range.startLineNumber === range.endLineNumber) &&\n      (range.startColumn === range.endColumn)\n    ) {\n      info.isAddition = true;\n    } else {\n      info.isReplacement = true;\n    }\n    // Get Position Of Range\n    info.startLineOfRange = range.startLineNumber === editableRange.startLineNumber;\n    info.startColumnOfRange = range.startColumn === editableRange.startColumn;\n\n    info.endLineOfRange = range.endLineNumber === editableRange.endLineNumber;\n    info.endColumnOfRange = range.endColumn === editableRange.endColumn;\n\n    info.middleLineOfRange = !info.startLineOfRange && !info.endLineOfRange;\n\n    // Editable Range Span\n    if (editableRange.startLineNumber === editableRange.endLineNumber) {\n      info.rangeIsSingleLine = true;\n    } else {\n      info.rangeIsMultiLine = true;\n    }\n    return info;\n  };\n  const updateRestrictions = function (ranges) {\n    restrictions = deepClone(ranges).sort(sortRangesInAscendingOrder);\n    prepareRestrictions(restrictions);\n  };\n  const toggleHighlightOfEditableAreas = function (cssClasses) {\n    if (!model._hasHighlight) {\n      const cssClassForSingleLine = cssClasses.cssClassForSingleLine ||enums.SINGLE_LINE_HIGHLIGHT_CLASS\n      const cssClassForMultiLine = cssClasses.cssClassForMultiLine ||enums.MULTI_LINE_HIGHLIGHT_CLASS\n      const decorations = restrictions.map(function (restriction) {\n        const decoration = {\n          range: restriction.range,\n          options: {\n            className: restriction.allowMultiline ?\n              cssClassForMultiLine :\n              cssClassForSingleLine\n          }\n        }\n        if (restriction.label) {\n          decoration.hoverMessage = restriction.label;\n        }\n        return decoration;\n      });\n      model._oldDecorations = model.deltaDecorations([], decorations);\n      model._oldDecorationsSource = decorations.map(function (decoration, index) {\n        return Object.assign({}, decoration, { id: model._oldDecorations[index] });\n      });\n      model._hasHighlight = true;\n    } else {\n      model.deltaDecorations(model._oldDecorations, []);\n      delete model._oldDecorations;\n      delete model._oldDecorationsSource;\n      model._hasHighlight = false;\n    }\n  }\n  const handleUnhandledPromiseRejection = function () {\n    console.debug('handler for unhandled promise rejection');\n  };\n  const setAllRangesToPrev = function (rangeMap) {\n    for (let key in rangeMap) {\n      const restriction = rangeMap[key];\n      restriction.range = restriction.prevRange;\n    }\n  };\n  const doesChangeHasMultilineConflict = function (restriction, text) {\n    return !restriction.allowMultiline && text.includes('\\n');\n  };\n  const isChangeInvalidAsPerUser = function (restriction, value, range) {\n    return restriction.validate && !restriction.validate(value, range, restriction.lastInfo);\n  }\n\n  const manipulatorApi = {\n    _isRestrictedModel: true,\n    _isRestrictedValueValid: true,\n    _editableRangeChangeListener: [],\n    _isCursorAtCheckPoint: isCursorAtCheckPoint,\n    _currentCursorPositions: []\n  }\n\n  prepareRestrictions(restrictions);\n  model._hasHighlight = false;\n  manipulatorApi._restrictionChangeListener = model.onDidChangeContent(function (contentChangedEvent) {\n    const isUndoing = contentChangedEvent.isUndoing;\n    model._isRestrictedValueValid = true;\n    if (!(isUndoing && model.editInRestrictedArea)) {\n      const changes = contentChangedEvent.changes.sort(sortRangesInAscendingOrder);\n      const rangeMap = {};\n      const length = restrictions.length;\n      const isAllChangesValid = changes.every(function (change) {\n        const editedRange = change.range;\n        const rangeAsString = editedRange.toString();\n        rangeMap[rangeAsString] = null;\n        for (let i = 0; i < length; i++) {\n          const restriction = restrictions[i];\n          const range = restriction.range;\n          if (range.containsRange(editedRange)) {\n            if (doesChangeHasMultilineConflict(restriction, change.text)) {\n              return false;\n            }\n            rangeMap[rangeAsString] = restriction;\n            return true;\n          }\n        }\n        return false;\n      })\n      if (isAllChangesValid) {\n        changes.forEach(function (change, changeIndex) {\n          const changedRange = change.range;\n          const restriction = rangeMap[changedRange.toString()];\n          const editableRange = restriction.range;\n          const text = change.text || '';\n          /**\n           * Things to check before implementing the change\n           * - A | D | R => Addition | Deletion | Replacement\n           * - MC | SC => MultiLineChange | SingleLineChange\n           * - SOR | MOR | EOR => Change Occured in - Start Of Range | Middle Of Range | End Of Range\n           * - SSL | SML => Editable Range - Spans Single Line | Spans Multiple Line\n           */\n          const noOfLinesAdded = (text.match(/\\n/g) || []).length;\n          const noOfColsAddedAtLastLine = text.split(/\\n/g).pop().length;\n\n          const lineDiffInRange = changedRange.endLineNumber - changedRange.startLineNumber;\n          const colDiffInRange = changedRange.endColumn - changedRange.startColumn;\n\n          let finalLine = editableRange.endLineNumber;\n          let finalColumn = editableRange.endColumn;\n\n          let columnsCarriedToEnd = 0;\n          if (\n            (editableRange.endLineNumber === changedRange.startLineNumber) ||\n            (editableRange.endLineNumber === changedRange.endLineNumber)\n          ) {\n            columnsCarriedToEnd += (editableRange.endColumn - changedRange.startColumn) + 1;\n          }\n\n          const info = getInfoFrom(change, editableRange);\n          restriction.lastInfo = info;\n          if (info.isAddition || info.isReplacement) {\n            if (info.rangeIsSingleLine) {\n              /**\n               * Only Column Change has occurred , so regardless of the position of the change\n               * Addition of noOfCols is enough\n               */\n              if (noOfLinesAdded === 0) {\n                finalColumn += noOfColsAddedAtLastLine;\n              } else {\n                finalLine += noOfLinesAdded;\n                if (info.startColumnOfRange) {\n                  finalColumn += noOfColsAddedAtLastLine\n                } else if (info.endColumnOfRange) {\n                  finalColumn = (noOfColsAddedAtLastLine + 1)\n                } else {\n                  finalColumn = (noOfColsAddedAtLastLine + columnsCarriedToEnd)\n                }\n              }\n            }\n            if (info.rangeIsMultiLine) {\n              // Handling for Start Of Range is not required\n              finalLine += noOfLinesAdded;\n              if (info.endLineOfRange) {\n                if (noOfLinesAdded === 0) {\n                  finalColumn += noOfColsAddedAtLastLine;\n                } else {\n                  finalColumn = (columnsCarriedToEnd + noOfColsAddedAtLastLine);\n                }\n              }\n            }\n          }\n          if (info.isDeletion || info.isReplacement) {\n            if (info.rangeIsSingleLine) {\n              finalColumn -= colDiffInRange;\n            }\n            if (info.rangeIsMultiLine) {\n              if (info.endLineOfRange) {\n                finalLine -= lineDiffInRange;\n                finalColumn -= colDiffInRange;\n              } else {\n                finalLine -= lineDiffInRange;\n              }\n            }\n          }\n          updateRange(restriction, editableRange, finalLine, finalColumn, changes, changeIndex);\n        });\n        const values = model.getValueInEditableRanges();\n        const currentlyEditedRanges = {};\n        for (let key in rangeMap) {\n          const restriction = rangeMap[key];\n          const range = restriction.range;\n          const rangeString = restriction.label || range.toString();\n          const value = values[rangeString];\n          if (isChangeInvalidAsPerUser(restriction, value, range)) {\n            setAllRangesToPrev(rangeMap);\n            doUndo();\n            return; // Breaks the loop and prevents the triggerChangeListener\n          }\n          currentlyEditedRanges[rangeString] = value;\n        }\n        if (model._hasHighlight) {\n          model._oldDecorationsSource.forEach(function (object) {\n            object.range = model.getDecorationRange(object.id);\n          });\n        }\n        triggerChangeListenersWith(currentlyEditedRanges, values);\n      } else {\n        doUndo();\n      }\n    } else if (model.editInRestrictedArea) {\n      model._isRestrictedValueValid = false;\n    }\n  });\n  window.onerror = handleUnhandledPromiseRejection;\n  const exposedApi = {\n    editInRestrictedArea: false,\n    getCurrentEditableRanges: getCurrentEditableRanges,\n    getValueInEditableRanges: getValueInEditableRanges,\n    disposeRestrictions: disposeRestrictions,\n    onDidChangeContentInEditableRange: addEditableRangeListener,\n    updateRestrictions: updateRestrictions,\n    updateValueInEditableRanges: updateValueInEditableRanges,\n    toggleHighlightOfEditableAreas: toggleHighlightOfEditableAreas\n  }\n  for (let funcName in manipulatorApi) {\n    Object.defineProperty(model, funcName, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: manipulatorApi[funcName]\n    })\n  }\n  for (let apiName in exposedApi) {\n    Object.defineProperty(model, apiName, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: exposedApi[apiName]\n    })\n  }\n  return model;\n}\nexport default constrainedModel;","export const deepClone = (function () {\n  const byPassPrimitives = function (value, callback) {\n    if (typeof value !== 'object' || value === null) {\n      return this.freeze ? Object.freeze(value) : value;\n    }\n    if (value instanceof Date) {\n      return this.freeze ? Object.freeze(new Date(value)) : new Date(value);\n    }\n    return callback.call(this, value);\n  }\n  const cloneArray = function (array, callback) {\n    const keys = Object.keys(array);\n    const arrayClone = new Array(keys.length)\n    for (let i = 0; i < keys.length; i++) {\n      arrayClone[keys[i]] = byPassPrimitives.call(this, array[keys[i]], callback);\n    }\n    return arrayClone;\n  }\n  const cloner = function (object) {\n    return byPassPrimitives.call(this, object, function (object) {\n      if (Array.isArray(object)) {\n        return cloneArray.call(this, object, cloner)\n      }\n      const clone = {};\n      for (let key in object) {\n        if (!this.withProto && Object.hasOwnProperty.call(object, key) === false) {\n          continue;\n        }\n        clone[key] = byPassPrimitives.call(this, object[key], cloner);\n      }\n      return clone;\n    })\n  }\n  const config = (function () {\n    const constructOptionForCode = function (value) {\n      const options = [\n        'withProto',\n        'freeze'\n      ]\n      this[value] = options.reduce(function (acc, option) {\n        if (acc[option] = (value >= this[option])) {\n          value -= this[option]\n        }\n        return acc;\n      }.bind(this), {})\n    }\n    const codes = Object.create(Object.defineProperties({}, {\n      withProto: { value: 1 },\n      freeze: { value: 2 }\n    }));\n    for (let i = 0; i <= 3; i++) {\n      constructOptionForCode.call(codes, i);\n    }\n    return codes;\n  }());\n  const methods = {\n    withProto: cloner.bind(config[1]),\n    andFreeze: cloner.bind(config[2]),\n    withProtoAndFreeze: cloner.bind(config[3])\n  }\n  const API = cloner.bind(config[0]);\n  for (let methodName in methods) {\n    Object.defineProperty(API, methodName, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: methods[methodName]\n    })\n  }\n  return API;\n}());\n\nexport default deepClone;","export const TypeMustBe = function (type, key, additional) {\n  return 'The value for the ' + key + ' should be of type ' + (Array.isArray(type) ? type.join(' | ') : type) + '. ' + (additional || '')\n}\nconst definedErrors = {\n  TypeMustBe : TypeMustBe\n};\nexport default definedErrors;","export const enums = {\n  SINGLE_LINE_HIGHLIGHT_CLASS: 'editableArea--single-line',\n  MULTI_LINE_HIGHLIGHT_CLASS: 'editableArea--multi-line'\n}\nexport default enums;","const validators = {\n  initWith: function (monaco) {\n    const dummyDiv = document.createElement('div');\n    const dummyEditorInstance = monaco.editor.create(dummyDiv);\n    const editorInstanceConstructorName = dummyEditorInstance.constructor.name;\n    const editorModelConstructorName = dummyEditorInstance.getModel().constructor.name;\n    const instanceCheck = function (valueToValidate) {\n      return valueToValidate.constructor.name === editorInstanceConstructorName;\n    }\n    const modelCheck = function (valueToValidate) {\n      return valueToValidate.constructor.name === editorModelConstructorName;\n    }\n    const rangesCheck = function (ranges) {\n      if (Array.isArray(ranges)) {\n        return ranges.every(function (rangeObj) {\n          if (typeof rangeObj === 'object' && rangeObj.constructor.name === 'Object') {\n            if (!rangeObj.hasOwnProperty('range')) return false;\n            if (!Array.isArray(rangeObj.range)) return false;\n            if (rangeObj.range.length !== 4) return false;\n            if (!(rangeObj.range.every(num => num > 0 && parseInt(num) === num))) return false;\n            if (rangeObj.hasOwnProperty('allowMultiline')) {\n              if (typeof rangeObj.allowMultiline !== 'boolean') return false;\n            }\n            if (rangeObj.hasOwnProperty('label')) {\n              if (typeof rangeObj.label !== 'string') return false;\n            }\n            if (rangeObj.hasOwnProperty('validate')) {\n              if (typeof rangeObj.validate !== 'function') return false;\n            }\n            return true;\n          }\n          return false;\n        });\n      }\n      return false;\n    }\n    return {\n      isInstanceValid: instanceCheck,\n      isModelValid: modelCheck,\n      isRangesValid: rangesCheck\n    }\n  }\n}\nexport default validators;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import validators from './utils/validators.js';\nimport { TypeMustBe } from './utils/definedErrors.js';\nimport constrainedModel from './constrainedModel.js';\n\nexport function constrainedEditor(monaco) {\n  /**\n   * Injected Dependencies\n   */\n  if (monaco === undefined) {\n    throw new Error([\n      \"Please pass the monaco global variable into function as\",\n      \"(eg:)constrainedEditor({ range : monaco.range });\",\n    ].join('\\n'));\n  }\n  /**\n   *\n   * @param {Object} editorInstance This should be the monaco editor instance.\n   * @description This is the listener function to check whether the cursor is at checkpoints\n   * (i.e) the point where editable and non editable portions meet\n   */\n  const listenerFn = function (editorInstance) {\n    const model = editorInstance.getModel();\n    if (model._isCursorAtCheckPoint) {\n      const selections = editorInstance.getSelections();\n      const positions = selections.map(function (selection) {\n        return {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n      model._isCursorAtCheckPoint(positions);\n      model._currentCursorPositions = selections;\n    }\n  }\n  const _uriRestrictionMap = {};\n  const { isInstanceValid, isModelValid, isRangesValid } = validators.initWith(monaco);\n  /**\n   *\n   * @param {Object} editorInstance This should be the monaco editor instance\n   * @returns {Boolean}\n   */\n  const initInEditorInstance = function (editorInstance) {\n    if (isInstanceValid(editorInstance)) {\n      let domNode = editorInstance.getDomNode();\n      manipulator._listener = listenerFn.bind(API, editorInstance);\n      manipulator._editorInstance = editorInstance;\n      manipulator._editorInstance._isInDevMode = false;\n      domNode.addEventListener('keydown', manipulator._listener, true);\n      manipulator._onChangeModelDisposable = editorInstance.onDidChangeModel(function () {\n        // domNode - refers old dom node\n        domNode && domNode.removeEventListener('keydown', manipulator._listener, true)\n        const newDomNode = editorInstance.getDomNode(); // Gets Current dom node\n        newDomNode && newDomNode.addEventListener('keydown', manipulator._listener, true);\n        domNode = newDomNode;\n      })\n      return true;\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @param {Object} model This should be the monaco editor model instance. Refer https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html\n   * @param {*} ranges This should be the array of range objects. Refer constrained editor plugin documentation\n   * @returns model\n   */\n  const addRestrictionsTo = function (model, ranges) {\n    if (isModelValid(model)) {\n      if (isRangesValid(ranges)) {\n        const modelToConstrain = constrainedModel(model, ranges, monaco, manipulator._editorInstance);\n        _uriRestrictionMap[modelToConstrain.uri.toString()] = modelToConstrain;\n        return modelToConstrain;\n      } else {\n        throw new Error(\n          TypeMustBe(\n            'Array<RangeRestrictionObject>',\n            'ranges',\n            'Please refer constrained editor documentation for proper structure'\n          )\n        )\n      }\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @param {Object} model This should be the monaco editor model instance. Refer https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html\n   * @returns {Boolean} True if the restrictions are removed\n   */\n  const removeRestrictionsIn = function (model) {\n    if (isModelValid(model)) {\n      const uri = model.uri.toString();\n      const restrictedModel = _uriRestrictionMap[uri];\n      if (restrictedModel) {\n        return restrictedModel.disposeRestrictions();\n      } else {\n        console.warn('Current Model is not a restricted Model');\n        return false;\n      }\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @returns {Boolean} True if the constrainer is disposed\n   */\n  const disposeConstrainer = function () {\n    if (manipulator._editorInstance) {\n      const instance = manipulator._editorInstance;\n      const domNode = instance.getDomNode();\n      domNode && domNode.removeEventListener('keydown', manipulator._listener);\n      manipulator._onChangeModelDisposable && manipulator._onChangeModelDisposable.dispose();\n      delete manipulator._listener;\n      delete manipulator._editorInstance._isInDevMode;\n      delete manipulator._editorInstance._devModeAction;\n      delete manipulator._editorInstance;\n      delete manipulator._onChangeModelDisposable;\n      for (let key in _uriRestrictionMap) {\n        delete _uriRestrictionMap[key];\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @description This function used to make the developer to find the ranges of selected portions\n   */\n  const toggleDevMode = function () {\n    if (manipulator._editorInstance._isInDevMode) {\n      manipulator._editorInstance._isInDevMode = false;\n      manipulator._editorInstance._devModeAction.dispose();\n      delete manipulator._editorInstance._devModeAction;\n    } else {\n      manipulator._editorInstance._isInDevMode = true;\n      manipulator._editorInstance._devModeAction = manipulator._editorInstance.addAction({\n        id: 'showRange',\n        label: 'Show Range in console',\n        contextMenuGroupId: 'navigation',\n        contextMenuOrder: 1.5,\n        run: function (editor) {\n          const selections = editor.getSelections();\n          const ranges = selections.reduce(function (acc, { startLineNumber, endLineNumber, startColumn, endColumn }) {\n            acc.push('range : ' + JSON.stringify([\n              startLineNumber,\n              startColumn,\n              endLineNumber,\n              endColumn\n            ]));\n            return acc;\n          }, []).join('\\n');\n          console.log(`Selected Ranges : \\n` + JSON.stringify(ranges, null, 2));\n        }\n      });\n    }\n  }\n\n  /**\n   * Main Function starts here\n   */\n  // @internal\n  const manipulator = {\n    /**\n     * These variables should not be modified by external code\n     * This has to be used for debugging and testing\n     */\n    _listener: null,\n    _editorInstance: null,\n    _uriRestrictionMap: _uriRestrictionMap,\n    _injectedResources: monaco\n  }\n  const API = Object.create(manipulator);\n  const exposedMethods = {\n    /**\n     * These functions are exposed to the user\n     * These functions should be protected from editing\n     */\n    initializeIn: initInEditorInstance,\n    addRestrictionsTo: addRestrictionsTo,\n    removeRestrictionsIn: removeRestrictionsIn,\n    disposeConstrainer: disposeConstrainer,\n    toggleDevMode: toggleDevMode\n  }\n  for (let methodName in exposedMethods) {\n    Object.defineProperty(API, methodName, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: exposedMethods[methodName]\n    })\n  }\n  return Object.freeze(API);\n}\n\nexport default constrainedEditor;\n"],"names":[],"sourceRoot":""}