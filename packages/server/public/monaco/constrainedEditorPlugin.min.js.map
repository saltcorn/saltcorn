{"version":3,"file":"constrainedEditorPlugin.min.js","mappings":"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","sources":["webpack://constrainedEditor/webpack/bootstrap","webpack://constrainedEditor/webpack/runtime/define property getters","webpack://constrainedEditor/webpack/runtime/hasOwnProperty shorthand","webpack://constrainedEditor/./src/utils/validators.js","webpack://constrainedEditor/./src/utils/definedErrors.js","webpack://constrainedEditor/./src/utils/deepClone.js","webpack://constrainedEditor/./src/utils/enums.js","webpack://constrainedEditor/./src/constrainedEditor.js","webpack://constrainedEditor/./src/constrainedModel.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","const validators = {\n  initWith: function (monaco) {\n    const dummyDiv = document.createElement('div');\n    const dummyEditorInstance = monaco.editor.create(dummyDiv);\n    const editorInstanceConstructorName = dummyEditorInstance.constructor.name;\n    const editorModelConstructorName = dummyEditorInstance.getModel().constructor.name;\n    const instanceCheck = function (valueToValidate) {\n      return valueToValidate.constructor.name === editorInstanceConstructorName;\n    }\n    const modelCheck = function (valueToValidate) {\n      return valueToValidate.constructor.name === editorModelConstructorName;\n    }\n    const rangesCheck = function (ranges) {\n      if (Array.isArray(ranges)) {\n        return ranges.every(function (rangeObj) {\n          if (typeof rangeObj === 'object' && rangeObj.constructor.name === 'Object') {\n            if (!rangeObj.hasOwnProperty('range')) return false;\n            if (!Array.isArray(rangeObj.range)) return false;\n            if (rangeObj.range.length !== 4) return false;\n            if (!(rangeObj.range.every(num => num > 0 && parseInt(num) === num))) return false;\n            if (rangeObj.hasOwnProperty('allowMultiline')) {\n              if (typeof rangeObj.allowMultiline !== 'boolean') return false;\n            }\n            if (rangeObj.hasOwnProperty('label')) {\n              if (typeof rangeObj.label !== 'string') return false;\n            }\n            if (rangeObj.hasOwnProperty('validate')) {\n              if (typeof rangeObj.validate !== 'function') return false;\n            }\n            return true;\n          }\n          return false;\n        });\n      }\n      return false;\n    }\n    return {\n      isInstanceValid: instanceCheck,\n      isModelValid: modelCheck,\n      isRangesValid: rangesCheck\n    }\n  }\n}\nexport default validators;","export const TypeMustBe = function (type, key, additional) {\n  return 'The value for the ' + key + ' should be of type ' + (Array.isArray(type) ? type.join(' | ') : type) + '. ' + (additional || '')\n}\nconst definedErrors = {\n  TypeMustBe : TypeMustBe\n};\nexport default definedErrors;","export const deepClone = (function () {\n  const byPassPrimitives = function (value, callback) {\n    if (typeof value !== 'object' || value === null) {\n      return this.freeze ? Object.freeze(value) : value;\n    }\n    if (value instanceof Date) {\n      return this.freeze ? Object.freeze(new Date(value)) : new Date(value);\n    }\n    return callback.call(this, value);\n  }\n  const cloneArray = function (array, callback) {\n    const keys = Object.keys(array);\n    const arrayClone = new Array(keys.length)\n    for (let i = 0; i < keys.length; i++) {\n      arrayClone[keys[i]] = byPassPrimitives.call(this, array[keys[i]], callback);\n    }\n    return arrayClone;\n  }\n  const cloner = function (object) {\n    return byPassPrimitives.call(this, object, function (object) {\n      if (Array.isArray(object)) {\n        return cloneArray.call(this, object, cloner)\n      }\n      const clone = {};\n      for (let key in object) {\n        if (!this.withProto && Object.hasOwnProperty.call(object, key) === false) {\n          continue;\n        }\n        clone[key] = byPassPrimitives.call(this, object[key], cloner);\n      }\n      return clone;\n    })\n  }\n  const config = (function () {\n    const constructOptionForCode = function (value) {\n      const options = [\n        'withProto',\n        'freeze'\n      ]\n      this[value] = options.reduce(function (acc, option) {\n        if (acc[option] = (value >= this[option])) {\n          value -= this[option]\n        }\n        return acc;\n      }.bind(this), {})\n    }\n    const codes = Object.create(Object.defineProperties({}, {\n      withProto: { value: 1 },\n      freeze: { value: 2 }\n    }));\n    for (let i = 0; i <= 3; i++) {\n      constructOptionForCode.call(codes, i);\n    }\n    return codes;\n  }());\n  const methods = {\n    withProto: cloner.bind(config[1]),\n    andFreeze: cloner.bind(config[2]),\n    withProtoAndFreeze: cloner.bind(config[3])\n  }\n  const API = cloner.bind(config[0]);\n  for (let methodName in methods) {\n    Object.defineProperty(API, methodName, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: methods[methodName]\n    })\n  }\n  return API;\n}());\n\nexport default deepClone;","export const enums = {\n  SINGLE_LINE_HIGHLIGHT_CLASS: 'editableArea--single-line',\n  MULTI_LINE_HIGHLIGHT_CLASS: 'editableArea--multi-line'\n}\nexport default enums;","import validators from './utils/validators.js';\nimport { TypeMustBe } from './utils/definedErrors.js';\nimport constrainedModel from './constrainedModel.js';\n\nexport function constrainedEditor(monaco) {\n  /**\n   * Injected Dependencies\n   */\n  if (monaco === undefined) {\n    throw new Error([\n      \"Please pass the monaco global variable into function as\",\n      \"(eg:)constrainedEditor({ range : monaco.range });\",\n    ].join('\\n'));\n  }\n  /**\n   *\n   * @param {Object} editorInstance This should be the monaco editor instance.\n   * @description This is the listener function to check whether the cursor is at checkpoints\n   * (i.e) the point where editable and non editable portions meet\n   */\n  const listenerFn = function (editorInstance) {\n    const model = editorInstance.getModel();\n    if (model._isCursorAtCheckPoint) {\n      const selections = editorInstance.getSelections();\n      const positions = selections.map(function (selection) {\n        return {\n          lineNumber: selection.positionLineNumber,\n          column: selection.positionColumn\n        }\n      });\n      model._isCursorAtCheckPoint(positions);\n      model._currentCursorPositions = selections;\n    }\n  }\n  const _uriRestrictionMap = {};\n  const { isInstanceValid, isModelValid, isRangesValid } = validators.initWith(monaco);\n  /**\n   *\n   * @param {Object} editorInstance This should be the monaco editor instance\n   * @returns {Boolean}\n   */\n  const initInEditorInstance = function (editorInstance) {\n    if (isInstanceValid(editorInstance)) {\n      let domNode = editorInstance.getDomNode();\n      manipulator._listener = listenerFn.bind(API, editorInstance);\n      manipulator._editorInstance = editorInstance;\n      manipulator._editorInstance._isInDevMode = false;\n      domNode.addEventListener('keydown', manipulator._listener, true);\n      manipulator._onChangeModelDisposable = editorInstance.onDidChangeModel(function () {\n        // domNode - refers old dom node\n        domNode && domNode.removeEventListener('keydown', manipulator._listener, true)\n        const newDomNode = editorInstance.getDomNode(); // Gets Current dom node\n        newDomNode && newDomNode.addEventListener('keydown', manipulator._listener, true);\n        domNode = newDomNode;\n      })\n      return true;\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @param {Object} model This should be the monaco editor model instance. Refer https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html\n   * @param {*} ranges This should be the array of range objects. Refer constrained editor plugin documentation\n   * @returns model\n   */\n  const addRestrictionsTo = function (model, ranges) {\n    if (isModelValid(model)) {\n      if (isRangesValid(ranges)) {\n        const modelToConstrain = constrainedModel(model, ranges, monaco, manipulator._editorInstance);\n        _uriRestrictionMap[modelToConstrain.uri.toString()] = modelToConstrain;\n        return modelToConstrain;\n      } else {\n        throw new Error(\n          TypeMustBe(\n            'Array<RangeRestrictionObject>',\n            'ranges',\n            'Please refer constrained editor documentation for proper structure'\n          )\n        )\n      }\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @param {Object} model This should be the monaco editor model instance. Refer https://microsoft.github.io/monaco-editor/api/interfaces/monaco.editor.itextmodel.html\n   * @returns {Boolean} True if the restrictions are removed\n   */\n  const removeRestrictionsIn = function (model) {\n    if (isModelValid(model)) {\n      const uri = model.uri.toString();\n      const restrictedModel = _uriRestrictionMap[uri];\n      if (restrictedModel) {\n        return restrictedModel.disposeRestrictions();\n      } else {\n        console.warn('Current Model is not a restricted Model');\n        return false;\n      }\n    } else {\n      throw new Error(\n        TypeMustBe(\n          'ICodeEditor',\n          'editorInstance',\n          'This type interface can be found in monaco editor documentation'\n        )\n      )\n    }\n  }\n  /**\n   *\n   * @returns {Boolean} True if the constrainer is disposed\n   */\n  const disposeConstrainer = function () {\n    if (manipulator._editorInstance) {\n      const instance = manipulator._editorInstance;\n      const domNode = instance.getDomNode();\n      domNode && domNode.removeEventListener('keydown', manipulator._listener);\n      manipulator._onChangeModelDisposable && manipulator._onChangeModelDisposable.dispose();\n      delete manipulator._listener;\n      delete manipulator._editorInstance._isInDevMode;\n      delete manipulator._editorInstance._devModeAction;\n      delete manipulator._editorInstance;\n      delete manipulator._onChangeModelDisposable;\n      for (let key in _uriRestrictionMap) {\n        delete _uriRestrictionMap[key];\n      }\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @description This function used to make the developer to find the ranges of selected portions\n   */\n  const toggleDevMode = function () {\n    if (manipulator._editorInstance._isInDevMode) {\n      manipulator._editorInstance._isInDevMode = false;\n      manipulator._editorInstance._devModeAction.dispose();\n      delete manipulator._editorInstance._devModeAction;\n    } else {\n      manipulator._editorInstance._isInDevMode = true;\n      manipulator._editorInstance._devModeAction = manipulator._editorInstance.addAction({\n        id: 'showRange',\n        label: 'Show Range in console',\n        contextMenuGroupId: 'navigation',\n        contextMenuOrder: 1.5,\n        run: function (editor) {\n          const selections = editor.getSelections();\n          const ranges = selections.reduce(function (acc, { startLineNumber, endLineNumber, startColumn, endColumn }) {\n            acc.push('range : ' + JSON.stringify([\n              startLineNumber,\n              startColumn,\n              endLineNumber,\n              endColumn\n            ]));\n            return acc;\n          }, []).join('\\n');\n          console.log(`Selected Ranges : \\n` + JSON.stringify(ranges, null, 2));\n        }\n      });\n    }\n  }\n\n  /**\n   * Main Function starts here\n   */\n  // @internal\n  const manipulator = {\n    /**\n     * These variables should not be modified by external code\n     * This has to be used for debugging and testing\n     */\n    _listener: null,\n    _editorInstance: null,\n    _uriRestrictionMap: _uriRestrictionMap,\n    _injectedResources: monaco\n  }\n  const API = Object.create(manipulator);\n  const exposedMethods = {\n    /**\n     * These functions are exposed to the user\n     * These functions should be protected from editing\n     */\n    initializeIn: initInEditorInstance,\n    addRestrictionsTo: addRestrictionsTo,\n    removeRestrictionsIn: removeRestrictionsIn,\n    disposeConstrainer: disposeConstrainer,\n    toggleDevMode: toggleDevMode\n  }\n  for (let methodName in exposedMethods) {\n    Object.defineProperty(API, methodName, {\n      enumerable: false,\n      writable: false,\n      configurable: false,\n      value: exposedMethods[methodName]\n    })\n  }\n  return Object.freeze(API);\n}\n\nexport default constrainedEditor;\n","import deepClone from './utils/deepClone.js';\nimport enums from './utils/enums.js';\nexport const constrainedModel = function (model, ranges, monaco) {\n  const rangeConstructor = monaco.Range;\n  const sortRangesInAscendingOrder = function (rangeObject1, rangeObject2) {\n    const rangeA = rangeObject1.range;\n    const rangeB = rangeObject2.range;\n    if (\n      rangeA[0] < rangeB[0] ||\n      (rangeA[0] === rangeB[0] && rangeA[3] < rangeB[1])\n    ) {\n      return -1;\n    }\n  }\n  const normalizeRange = function (range, content) {\n    const lines = content.split('\\n');\n    const noOfLines = lines.length;\n    const normalizedRange = [];\n    range.forEach(function (value, index) {\n      if (value === 0) {\n        throw new Error('Range values cannot be zero');//No I18n\n      }\n      switch (index) {\n        case 0: {\n          if (value < 0) {\n            throw new Error('Start Line of Range cannot be negative');//No I18n\n          } else if (value > noOfLines) {\n            throw new Error('Provided Start Line(' + value + ') is out of bounds. Max Lines in content is ' + noOfLines);//No I18n\n          }\n          normalizedRange[index] = value;\n        }\n          break;\n        case 1: {\n          let actualStartCol = value;\n          const startLineNo = normalizedRange[0];\n          const maxCols = lines[startLineNo - 1].length\n          if (actualStartCol < 0) {\n            actualStartCol = maxCols - Math.abs(actualStartCol);\n            if (actualStartCol < 0) {\n              throw new Error('Provided Start Column(' + value + ') is out of bounds. Max Column in line ' + startLineNo + ' is ' + maxCols);//No I18n\n            }\n          } else if (actualStartCol > (maxCols + 1)) {\n            throw new Error('Provided Start Column(' + value + ') is out of bounds. Max Column in line ' + startLineNo + ' is ' + maxCols);//No I18n\n          }\n          normalizedRange[index] = actualStartCol;\n        }\n          break;\n        case 2: {\n          let actualEndLine = value;\n          if (actualEndLine < 0) {\n            actualEndLine = noOfLines - Math.abs(value);\n            if (actualEndLine < 0) {\n              throw new Error('Provided End Line(' + value + ') is out of bounds. Max Lines in content is ' + noOfLines);//No I18n\n            }\n            if (actualEndLine < normalizedRange[0]) {\n              console.warn('Provided End Line(' + value + ') is less than the start Line, the Restriction may not behave as expected');//No I18n\n            }\n          } else if (value > noOfLines) {\n            throw new Error('Provided End Line(' + value + ') is out of bounds. Max Lines in content is ' + noOfLines);//No I18n\n          }\n          normalizedRange[index] = actualEndLine;\n        }\n          break;\n        case 3: {\n          let actualEndCol = value;\n          const endLineNo = normalizedRange[2];\n          const maxCols = lines[endLineNo - 1].length\n          if (actualEndCol < 0) {\n            actualEndCol = maxCols - Math.abs(actualEndCol);\n            if (actualEndCol < 0) {\n              throw new Error('Provided End Column(' + value + ') is out of bounds. Max Column in line ' + endLineNo + ' is ' + maxCols);//No I18n\n            }\n          } else if (actualEndCol > (maxCols + 1)) {\n            throw new Error('Provided Start Column(' + value + ') is out of bounds. Max Column in line ' + endLineNo + ' is ' + maxCols);//No I18n\n          }\n          normalizedRange[index] = actualEndCol;\n        }\n          break;\n      }\n    })\n    return normalizedRange;\n  }\n  let restrictions = deepClone(ranges).sort(sortRangesInAscendingOrder);\n  const prepareRestrictions = function (restrictions) {\n    const content = model.getValue();\n    restrictions.forEach(function (restriction, index) {\n      const range = normalizeRange(restriction.range, content);\n      const startLine = range[0];\n      const startCol = range[1];\n      const endLine = range[2];\n      const endCol = range[3];\n      restriction._originalRange = range.slice();\n      restriction.range = new rangeConstructor(startLine, startCol, endLine, endCol);\n      restriction.index = index;\n      if (!restriction.allowMultiline) {\n        restriction.allowMultiline = rangeConstructor.spansMultipleLines(restriction.range)\n      }\n      if (!restriction.label) {\n        restriction.label = `[${startLine},${startCol} -> ${endLine}${endCol}]`;\n      }\n    });\n  }\n  const getCurrentEditableRanges = function () {\n    return restrictions.reduce(function (acc, restriction) {\n      acc[restriction.label] = {\n        allowMultiline: restriction.allowMultiline || false,\n        index: restriction.index,\n        range: Object.assign({}, restriction.range),\n        originalRange: restriction._originalRange.slice()\n      };\n      return acc;\n    }, {});\n  }\n  const getValueInEditableRanges = function () {\n    return restrictions.reduce(function (acc, restriction) {\n      acc[restriction.label] = model.getValueInRange(restriction.range);\n      return acc;\n    }, {});\n  }\n  const updateValueInEditableRanges = function (object, forceMoveMarkers) {\n    if (typeof object === 'object' && !Array.isArray(object)) {\n      forceMoveMarkers = typeof forceMoveMarkers === 'boolean' ? forceMoveMarkers : false;\n      const restrictionsMap = restrictions.reduce(function (acc, restriction) {\n        if (restriction.label) {\n          acc[restriction.label] = restriction;\n        }\n        return acc;\n      }, {});\n      for (let label in object) {\n        const restriction = restrictionsMap[label];\n        if (restriction) {\n          const value = object[label];\n          if (doesChangeHasMultilineConflict(restriction, value)) {\n            throw new Error('Multiline change is not allowed for ' + label);\n          }\n          const newRange = deepClone(restriction.range);\n          newRange.endLine = newRange.startLine + value.split('\\n').length - 1;\n          newRange.endColumn = value.split('\\n').pop().length;\n          if (isChangeInvalidAsPerUser(restriction, value, newRange)) {\n            throw new Error('Change is invalidated by validate function of ' + label);\n          }\n          model.applyEdits([{\n            forceMoveMarkers: !!forceMoveMarkers,\n            range: restriction.range,\n            text: value\n          }]);\n        } else {\n          console.error('No restriction found for ' + label);\n        }\n      }\n    } else {\n      throw new Error('Value must be an object');//No I18n\n    }\n  }\n  const disposeRestrictions = function () {\n    model._restrictionChangeListener.dispose();\n    window.removeEventListener(\"error\", handleUnhandledPromiseRejection);\n    delete model.editInRestrictedArea;\n    delete model.disposeRestrictions;\n    delete model.getValueInEditableRanges;\n    delete model.updateValueInEditableRanges;\n    delete model.updateRestrictions;\n    delete model.getCurrentEditableRanges;\n    delete model.toggleHighlightOfEditableAreas;\n    delete model._hasHighlight;\n    delete model._isRestrictedModel;\n    delete model._isCursorAtCheckPoint;\n    delete model._currentCursorPositions;\n    delete model._editableRangeChangeListener;\n    delete model._restrictionChangeListener;\n    delete model._oldDecorations;\n    delete model._oldDecorationsSource;\n    return model;\n  }\n  const isCursorAtCheckPoint = function (positions) {\n    positions.some(function (position) {\n      const posLineNumber = position.lineNumber;\n      const posCol = position.column;\n      const length = restrictions.length;\n      for (let i = 0; i < length; i++) {\n        const range = restrictions[i].range;\n        if (\n          (range.startLineNumber === posLineNumber && range.startColumn === posCol) ||\n          (range.endLineNumber === posLineNumber && range.endColumn === posCol)\n        ) {\n          model.pushStackElement();\n          return true;\n        }\n      }\n    });\n  };\n  const addEditableRangeListener = function (callback) {\n    if (typeof callback === 'function') {\n      model._editableRangeChangeListener.push(callback);\n    }\n  };\n  const triggerChangeListenersWith = function (currentChanges, allChanges) {\n    const currentRanges = getCurrentEditableRanges();\n    model._editableRangeChangeListener.forEach(function (callback) {\n      callback.call(model, currentChanges, allChanges, currentRanges);\n    });\n  };\n  const doUndo = function () {\n    return Promise.resolve().then(function () {\n      model.editInRestrictedArea = true;\n      model.undo();\n      model.editInRestrictedArea = false;\n      if (model._hasHighlight && model._oldDecorationsSource) {\n        // id present in the decorations info will be omitted by monaco\n        // So we don't need to remove the old decorations id\n        model.deltaDecorations(model._oldDecorations, model._oldDecorationsSource);\n        model._oldDecorationsSource.forEach(function (object) {\n          object.range = model.getDecorationRange(object.id);\n        });\n      }\n    });\n  };\n  const updateRange = function (restriction, range, finalLine, finalColumn, changes, changeIndex) {\n    let oldRangeEndLineNumber = range.endLineNumber;\n    let oldRangeEndColumn = range.endColumn;\n    restriction.prevRange = range;\n    restriction.range = range.setEndPosition(finalLine, finalColumn);\n    const length = restrictions.length;\n    let changesLength = changes.length;\n    const diffInCol = finalColumn - oldRangeEndColumn;\n    const diffInRow = finalLine - oldRangeEndLineNumber;\n\n    const cursorPositions = model._currentCursorPositions || [];\n    const noOfCursorPositions = cursorPositions.length;\n    // if (noOfCursorPositions > 0) {\n    if (changesLength !== noOfCursorPositions) {\n      changes = changes.filter(function (change) {\n        const range = change.range;\n        for (let i = 0; i < noOfCursorPositions; i++) {\n          const cursorPosition = cursorPositions[i];\n          if (\n            (range.startLineNumber === cursorPosition.startLineNumber) &&\n            (range.endLineNumber === cursorPosition.endLineNumber) &&\n            (range.startColumn === cursorPosition.startColumn) &&\n            (range.endColumn === cursorPosition.endColumn)\n          ) {\n            return true;\n          }\n        }\n        return false;\n      });\n      changesLength = changes.length;\n    }\n    if (diffInRow !== 0) {\n      for (let i = restriction.index + 1; i < length; i++) {\n        const nextRestriction = restrictions[i];\n        const nextRange = nextRestriction.range;\n        if (oldRangeEndLineNumber === nextRange.startLineNumber) {\n          nextRange.startColumn += diffInCol;\n        }\n        if (oldRangeEndLineNumber === nextRange.endLineNumber) {\n          nextRange.endColumn += diffInCol;\n        }\n        nextRange.startLineNumber += diffInRow;\n        nextRange.endLineNumber += diffInRow;\n        nextRestriction.range = nextRange;\n      }\n      for (let i = changeIndex + 1; i < changesLength; i++) {\n        const nextChange = changes[i];\n        const rangeInChange = nextChange.range;\n        const rangeAsString = rangeInChange.toString();\n        const rangeMapValue = rangeMap[rangeAsString];\n        delete rangeMap[rangeAsString];\n        if (oldRangeEndLineNumber === rangeInChange.startLineNumber) {\n          rangeInChange.startColumn += diffInCol;\n        }\n        if (oldRangeEndLineNumber === rangeInChange.endLineNumber) {\n          rangeInChange.endColumn += diffInCol;\n        }\n        rangeInChange.startLineNumber += diffInRow;\n        rangeInChange.endLineNumber += diffInRow;\n        nextChange.range = rangeInChange;\n        rangeMap[rangeInChange.toString()] = rangeMapValue;\n      }\n    } else {\n      // Only Column might have changed\n      for (let i = restriction.index + 1; i < length; i++) {\n        const nextRestriction = restrictions[i];\n        const nextRange = nextRestriction.range;\n        if (nextRange.startLineNumber > oldRangeEndLineNumber) {\n          break;\n        } else {\n          nextRange.startColumn += diffInCol;\n          nextRange.endColumn += diffInCol;\n          nextRestriction.range = nextRange;\n        }\n      }\n      for (let i = changeIndex + 1; i < changesLength; i++) {\n        // rangeMap\n        const nextChange = changes[i];\n        const rangeInChange = nextChange.range;\n        const rangeAsString = rangeInChange.toString();\n        const rangeMapValue = rangeMap[rangeAsString];\n        delete rangeMap[rangeAsString];\n        if (rangeInChange.startLineNumber > oldRangeEndLineNumber) {\n          rangeMap[rangeInChange.toString()] = rangeMapValue;\n          break;\n        } else {\n          rangeInChange.startColumn += diffInCol;\n          rangeInChange.endColumn += diffInCol;\n          nextChange.range = rangeInChange;\n          rangeMap[rangeInChange.toString()] = rangeMapValue;\n        }\n      }\n    }\n    // }\n  };\n  const getInfoFrom = function (change, editableRange) {\n    const info = {};\n    const range = change.range;\n    // Get State\n    if (change.text === '') {\n      info.isDeletion = true;\n    } else if (\n      (range.startLineNumber === range.endLineNumber) &&\n      (range.startColumn === range.endColumn)\n    ) {\n      info.isAddition = true;\n    } else {\n      info.isReplacement = true;\n    }\n    // Get Position Of Range\n    info.startLineOfRange = range.startLineNumber === editableRange.startLineNumber;\n    info.startColumnOfRange = range.startColumn === editableRange.startColumn;\n\n    info.endLineOfRange = range.endLineNumber === editableRange.endLineNumber;\n    info.endColumnOfRange = range.endColumn === editableRange.endColumn;\n\n    info.middleLineOfRange = !info.startLineOfRange && !info.endLineOfRange;\n\n    // Editable Range Span\n    if (editableRange.startLineNumber === editableRange.endLineNumber) {\n      info.rangeIsSingleLine = true;\n    } else {\n      info.rangeIsMultiLine = true;\n    }\n    return info;\n  };\n  const updateRestrictions = function (ranges) {\n    restrictions = deepClone(ranges).sort(sortRangesInAscendingOrder);\n    prepareRestrictions(restrictions);\n  };\n  const toggleHighlightOfEditableAreas = function (cssClasses) {\n    if (!model._hasHighlight) {\n      const cssClassForSingleLine = cssClasses.cssClassForSingleLine ||enums.SINGLE_LINE_HIGHLIGHT_CLASS\n      const cssClassForMultiLine = cssClasses.cssClassForMultiLine ||enums.MULTI_LINE_HIGHLIGHT_CLASS\n      const decorations = restrictions.map(function (restriction) {\n        const decoration = {\n          range: restriction.range,\n          options: {\n            className: restriction.allowMultiline ?\n              cssClassForMultiLine :\n              cssClassForSingleLine\n          }\n        }\n        if (restriction.label) {\n          decoration.hoverMessage = restriction.label;\n        }\n        return decoration;\n      });\n      model._oldDecorations = model.deltaDecorations([], decorations);\n      model._oldDecorationsSource = decorations.map(function (decoration, index) {\n        return Object.assign({}, decoration, { id: model._oldDecorations[index] });\n      });\n      model._hasHighlight = true;\n    } else {\n      model.deltaDecorations(model._oldDecorations, []);\n      delete model._oldDecorations;\n      delete model._oldDecorationsSource;\n      model._hasHighlight = false;\n    }\n  }\n  const handleUnhandledPromiseRejection = function () {\n    console.debug('handler for unhandled promise rejection');\n  };\n  const setAllRangesToPrev = function (rangeMap) {\n    for (let key in rangeMap) {\n      const restriction = rangeMap[key];\n      restriction.range = restriction.prevRange;\n    }\n  };\n  const doesChangeHasMultilineConflict = function (restriction, text) {\n    return !restriction.allowMultiline && text.includes('\\n');\n  };\n  const isChangeInvalidAsPerUser = function (restriction, value, range) {\n    return restriction.validate && !restriction.validate(value, range, restriction.lastInfo);\n  }\n\n  const manipulatorApi = {\n    _isRestrictedModel: true,\n    _isRestrictedValueValid: true,\n    _editableRangeChangeListener: [],\n    _isCursorAtCheckPoint: isCursorAtCheckPoint,\n    _currentCursorPositions: []\n  }\n\n  prepareRestrictions(restrictions);\n  model._hasHighlight = false;\n  manipulatorApi._restrictionChangeListener = model.onDidChangeContent(function (contentChangedEvent) {\n    const isUndoing = contentChangedEvent.isUndoing;\n    model._isRestrictedValueValid = true;\n    if (!(isUndoing && model.editInRestrictedArea)) {\n      const changes = contentChangedEvent.changes.sort(sortRangesInAscendingOrder);\n      const rangeMap = {};\n      const length = restrictions.length;\n      const isAllChangesValid = changes.every(function (change) {\n        const editedRange = change.range;\n        const rangeAsString = editedRange.toString();\n        rangeMap[rangeAsString] = null;\n        for (let i = 0; i < length; i++) {\n          const restriction = restrictions[i];\n          const range = restriction.range;\n          if (range.containsRange(editedRange)) {\n            if (doesChangeHasMultilineConflict(restriction, change.text)) {\n              return false;\n            }\n            rangeMap[rangeAsString] = restriction;\n            return true;\n          }\n        }\n        return false;\n      })\n      if (isAllChangesValid) {\n        changes.forEach(function (change, changeIndex) {\n          const changedRange = change.range;\n          const restriction = rangeMap[changedRange.toString()];\n          const editableRange = restriction.range;\n          const text = change.text || '';\n          /**\n           * Things to check before implementing the change\n           * - A | D | R => Addition | Deletion | Replacement\n           * - MC | SC => MultiLineChange | SingleLineChange\n           * - SOR | MOR | EOR => Change Occured in - Start Of Range | Middle Of Range | End Of Range\n           * - SSL | SML => Editable Range - Spans Single Line | Spans Multiple Line\n           */\n          const noOfLinesAdded = (text.match(/\\n/g) || []).length;\n          const noOfColsAddedAtLastLine = text.split(/\\n/g).pop().length;\n\n          const lineDiffInRange = changedRange.endLineNumber - changedRange.startLineNumber;\n          const colDiffInRange = changedRange.endColumn - changedRange.startColumn;\n\n          let finalLine = editableRange.endLineNumber;\n          let finalColumn = editableRange.endColumn;\n\n          let columnsCarriedToEnd = 0;\n          if (\n            (editableRange.endLineNumber === changedRange.startLineNumber) ||\n            (editableRange.endLineNumber === changedRange.endLineNumber)\n          ) {\n            columnsCarriedToEnd += (editableRange.endColumn - changedRange.startColumn) + 1;\n          }\n\n          const info = getInfoFrom(change, editableRange);\n          restriction.lastInfo = info;\n          if (info.isAddition || info.isReplacement) {\n            if (info.rangeIsSingleLine) {\n              /**\n               * Only Column Change has occurred , so regardless of the position of the change\n               * Addition of noOfCols is enough\n               */\n              if (noOfLinesAdded === 0) {\n                finalColumn += noOfColsAddedAtLastLine;\n              } else {\n                finalLine += noOfLinesAdded;\n                if (info.startColumnOfRange) {\n                  finalColumn += noOfColsAddedAtLastLine\n                } else if (info.endColumnOfRange) {\n                  finalColumn = (noOfColsAddedAtLastLine + 1)\n                } else {\n                  finalColumn = (noOfColsAddedAtLastLine + columnsCarriedToEnd)\n                }\n              }\n            }\n            if (info.rangeIsMultiLine) {\n              // Handling for Start Of Range is not required\n              finalLine += noOfLinesAdded;\n              if (info.endLineOfRange) {\n                if (noOfLinesAdded === 0) {\n                  finalColumn += noOfColsAddedAtLastLine;\n                } else {\n                  finalColumn = (columnsCarriedToEnd + noOfColsAddedAtLastLine);\n                }\n              }\n            }\n          }\n          if (info.isDeletion || info.isReplacement) {\n            if (info.rangeIsSingleLine) {\n              finalColumn -= colDiffInRange;\n            }\n            if (info.rangeIsMultiLine) {\n              if (info.endLineOfRange) {\n                finalLine -= lineDiffInRange;\n                finalColumn -= colDiffInRange;\n              } else {\n                finalLine -= lineDiffInRange;\n              }\n            }\n          }\n          updateRange(restriction, editableRange, finalLine, finalColumn, changes, changeIndex);\n        });\n        const values = model.getValueInEditableRanges();\n        const currentlyEditedRanges = {};\n        for (let key in rangeMap) {\n          const restriction = rangeMap[key];\n          const range = restriction.range;\n          const rangeString = restriction.label || range.toString();\n          const value = values[rangeString];\n          if (isChangeInvalidAsPerUser(restriction, value, range)) {\n            setAllRangesToPrev(rangeMap);\n            doUndo();\n            return; // Breaks the loop and prevents the triggerChangeListener\n          }\n          currentlyEditedRanges[rangeString] = value;\n        }\n        if (model._hasHighlight) {\n          model._oldDecorationsSource.forEach(function (object) {\n            object.range = model.getDecorationRange(object.id);\n          });\n        }\n        triggerChangeListenersWith(currentlyEditedRanges, values);\n      } else {\n        doUndo();\n      }\n    } else if (model.editInRestrictedArea) {\n      model._isRestrictedValueValid = false;\n    }\n  });\n  window.onerror = handleUnhandledPromiseRejection;\n  const exposedApi = {\n    editInRestrictedArea: false,\n    getCurrentEditableRanges: getCurrentEditableRanges,\n    getValueInEditableRanges: getValueInEditableRanges,\n    disposeRestrictions: disposeRestrictions,\n    onDidChangeContentInEditableRange: addEditableRangeListener,\n    updateRestrictions: updateRestrictions,\n    updateValueInEditableRanges: updateValueInEditableRanges,\n    toggleHighlightOfEditableAreas: toggleHighlightOfEditableAreas\n  }\n  for (let funcName in manipulatorApi) {\n    Object.defineProperty(model, funcName, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: manipulatorApi[funcName]\n    })\n  }\n  for (let apiName in exposedApi) {\n    Object.defineProperty(model, apiName, {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: exposedApi[apiName]\n    })\n  }\n  return model;\n}\nexport default constrainedModel;"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","monaco","dummyDiv","document","createElement","dummyEditorInstance","editor","create","editorInstanceConstructorName","constructor","name","editorModelConstructorName","getModel","isInstanceValid","valueToValidate","isModelValid","isRangesValid","ranges","Array","isArray","every","rangeObj","range","length","num","parseInt","allowMultiline","label","validate","TypeMustBe","type","additional","join","byPassPrimitives","value","callback","this","freeze","Date","cloneArray","array","keys","arrayClone","i","cloner","object","clone","withProto","config","constructOptionForCode","reduce","acc","option","bind","codes","defineProperties","methods","andFreeze","withProtoAndFreeze","API","methodName","writable","configurable","undefined","Error","listenerFn","editorInstance","model","_isCursorAtCheckPoint","selections","getSelections","positions","map","selection","lineNumber","positionLineNumber","column","positionColumn","_currentCursorPositions","_uriRestrictionMap","manipulator","_listener","_editorInstance","_injectedResources","exposedMethods","initializeIn","domNode","getDomNode","_isInDevMode","addEventListener","_onChangeModelDisposable","onDidChangeModel","removeEventListener","newDomNode","addRestrictionsTo","modelToConstrain","rangeConstructor","Range","sortRangesInAscendingOrder","rangeObject1","rangeObject2","rangeA","rangeB","restrictions","sort","prepareRestrictions","content","getValue","forEach","restriction","index","lines","split","noOfLines","normalizedRange","actualStartCol","startLineNo","maxCols","Math","abs","actualEndLine","console","warn","actualEndCol","endLineNo","normalizeRange","startLine","startCol","endLine","endCol","_originalRange","slice","spansMultipleLines","getCurrentEditableRanges","assign","originalRange","doUndo","Promise","resolve","then","editInRestrictedArea","undo","_hasHighlight","_oldDecorationsSource","deltaDecorations","_oldDecorations","getDecorationRange","id","updateRange","finalLine","finalColumn","changes","changeIndex","oldRangeEndLineNumber","endLineNumber","oldRangeEndColumn","endColumn","prevRange","setEndPosition","changesLength","diffInCol","diffInRow","cursorPositions","noOfCursorPositions","filter","change","cursorPosition","startLineNumber","startColumn","nextRestriction","nextRange","nextChange","rangeInChange","rangeAsString","toString","rangeMapValue","rangeMap","handleUnhandledPromiseRejection","debug","setAllRangesToPrev","doesChangeHasMultilineConflict","text","includes","isChangeInvalidAsPerUser","lastInfo","manipulatorApi","_isRestrictedModel","_isRestrictedValueValid","_editableRangeChangeListener","some","position","posLineNumber","posCol","pushStackElement","_restrictionChangeListener","onDidChangeContent","contentChangedEvent","isUndoing","editedRange","containsRange","changedRange","editableRange","noOfLinesAdded","match","noOfColsAddedAtLastLine","pop","lineDiffInRange","colDiffInRange","columnsCarriedToEnd","info","isDeletion","isAddition","isReplacement","startLineOfRange","startColumnOfRange","endLineOfRange","endColumnOfRange","middleLineOfRange","rangeIsSingleLine","rangeIsMultiLine","getInfoFrom","values","getValueInEditableRanges","currentlyEditedRanges","rangeString","currentChanges","allChanges","currentRanges","triggerChangeListenersWith","window","onerror","exposedApi","getValueInRange","disposeRestrictions","dispose","updateValueInEditableRanges","updateRestrictions","toggleHighlightOfEditableAreas","onDidChangeContentInEditableRange","push","forceMoveMarkers","restrictionsMap","newRange","applyEdits","error","cssClasses","cssClassForSingleLine","cssClassForMultiLine","decorations","decoration","options","className","hoverMessage","funcName","apiName","uri","removeRestrictionsIn","restrictedModel","disposeConstrainer","_devModeAction","toggleDevMode","addAction","contextMenuGroupId","contextMenuOrder","run","JSON","stringify","log"],"sourceRoot":""}